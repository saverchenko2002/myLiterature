# Что читаю сейчас:

Шилдт-Герберт-Java-8-руководство-для-начинающих-6-е-издание-2015 - currentProgress ( 326/641 )

# Что планирую читать:

Эккель Философия Java + SCM git 
___________________________________________________________

01.12.2020 Главы 1-3 : Страницы 25-126; 

Один интерфейс - множество методов(полиморфизм)
Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации.
Сокрытие доступа к методу methodName, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, 
так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Освежил память по логическим простым исключающим и укороченным логическим;

Открыл для себя ввод в консоль с клавиатуры(в нынешних реалиях где везде граф. интерфейс - бесполезно);

Узнал про goto замену в виде
doneblock:
{
        //someCode;
        break doneblock;
}
continue here;

Освежил память по приведению примитивных типов;
___________________________________________________________

03.12.2020 Главы 4-8 : Страница 126-323; 

Класс инкапсулирует функциональные возможности
В Java есть пул(pool) целых чисел в промежутке [-128;127]. 
Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. 
Таким образом, в первом примере i1 и i2 указывают на один и тот же объект из пула, а во втором - создаются два разных объекта.

Сначала объявляется переменная ссылающаяся на класс (не ссылается на конкретный объект)
затем выделяется память для экземпляра класса
и ссылка присваивается переменной

Стек - это набор элементов с организацией доступа по принципу "первым пришел - последним обслужен",
а очередь - это набор элементов с организацией доступа по принципу "первым пришел - первым обслужен". 
Стек можно сравнить со стопкой тарелок на столе: первая тарелка снизу стопки используется последней. 
А очередь можно сравнить с выстроившейся очередью к окошку в банке: клиент, стоящий в очереди первым, обслуживается первым.


Ниже приведена общая форма разновидности for-each цикла for. 
fоr(тип итр_пер : коллекция) 
блок_операторов

Инкапсуляция не позволяет видоизменить объект 
Приват поле ссылка на массив и размер массива 
они приват -> нельзя позже обратиться к конкретному эл-ту массива за границей массива и словить ошибку
обращение только через методы которые если что обработают выход за границу


Перегрузка методов является одним из способов реализации принципа полиморфизма в Java.

Перегрузка методов поддерживает полиморфизм, поскольку она является одним из способов реализации парадигмы "один интерфейс - множество методов".

В методе типа static допускается непосредственный вызов только других методов типа static; 
для метода типа static непосредственно доступными оказываются только друтие данные типа static, определенные в его классе; 
в методе типа static должна отсутствовать ссылка this.

Статический вложенный класс объявляется с помощью модификатора static. 
Являясь статическим, он может непосредственно обращаться к любому статическому члену своего внешнего класса. 
Другие члены внешнего класса доступны ему посредством ссылки на объект. 


Смысл статического вложенного класса? 
мой пример : во внешнем классе написать кучу отдельных методов, в статическом их обобщить в 1 глобальный
Вызов вида: VneshniyClass.InnerClass.methodName(VneshniyClass ob)|

Итак, имея в своем распоряжении суперкласс, определяющий общие свойства некоторых объектов, 
можно создать на его основе специализированные подклассы. 
Каждый подкласс дополняет свойства суперкласса собственными уникальными свойствами.
В этом и состоит сущность наследования. 

Вообще говоря, ссылочная переменная может указывать только на объекты своего типа.

Про полиморфизм 
есть надкласс с методом и от него есть два разных подкласса с переопределенным методом
создаю ссылку на надкласс  и присваиваю ей поочередно ссылку проинициализрованного надкласса и двух подклассов; 
-> вызываются соотв  переопр. методы

Подклассы получают достаточную свободу в определении собственных методов, реализуя в то же время согласованный интерфейс. 
Сочетая наследование с переопределением методов, в суперклассе можно определить общую форму методов для использования во всех ero подклассах.
Ссылочная переменная суперкласса может ссылаться на объект его подкласса.
Ключевое слово final позволяет без труда запретить переопределение метода или наследование класса.

С точки зрения синтаксиса интерфейсы подобны абстрактным классам. 
Но в интерфейсе ни у одного из методов не должно быть тела.
Это означает, что в интерфейсе вообще не предоставляется никакой реализации. 
В нем указывается только, что именно следует делать, но не как это делать. 
Как только интерфейс будет определен, он может быть реализован в любом количестве классов.
Кроме того, в одном классе может быть реализовано любое количество интерфейсов.

Интерфейсные ссылки - можно создать interfaceName varName; 
ее можно приравнивать к экземплярам классов реализующих интерфейс этот
и через нее можно вызывать переопределенные методы, к ост данным доступа не будет

В интерфейсе можно сделать реализацию метода (по умолчанию) дописав default и реализацию
чтобы не делать переопределение в классе использующим интерфейс и не нарушать работу программы

Следует также отметить, что статические методы интерфейса не наследуются ни реализующим его классом, ни производными интерфейсами.
___________________________________________________________

05.12.2020
