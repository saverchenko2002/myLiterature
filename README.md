# Что читаю сейчас:

Шилдт-Герберт-Java-8-руководство-для-начинающих-6-е-издание-2015 - currentProgress ( 524/641 (брошено?) )

# Что планирую читать:

Эккель Философия Java + SCM git + Блинов Java(?)
___________________________________________________________
# Шилдт-Герберт-Java-8-руководство-для-начинающих-6-е-издание-2015
___________________________________________________________

01.12.2020 Главы 1-3 : Страницы 25-126; 

Один интерфейс - множество методов(полиморфизм)
Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации.
Сокрытие доступа к методу methodName, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, 
так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Освежил память по логическим простым исключающим и укороченным логическим;

Открыл для себя ввод в консоль с клавиатуры(в нынешних реалиях где везде граф. интерфейс - бесполезно);

Узнал про goto замену в виде
doneblock:
{
        //someCode;
        break doneblock;
}
continue here;

Освежил память по приведению примитивных типов;
___________________________________________________________

03.12.2020 Главы 4-8 : Страница 126-323; 

Класс инкапсулирует функциональные возможности
В Java есть пул(pool) целых чисел в промежутке [-128;127]. 
Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. 
Таким образом, в первом примере i1 и i2 указывают на один и тот же объект из пула, а во втором - создаются два разных объекта.

Сначала объявляется переменная ссылающаяся на класс (не ссылается на конкретный объект)
затем выделяется память для экземпляра класса
и ссылка присваивается переменной

Стек - это набор элементов с организацией доступа по принципу "первым пришел - последним обслужен",
а очередь - это набор элементов с организацией доступа по принципу "первым пришел - первым обслужен". 
Стек можно сравнить со стопкой тарелок на столе: первая тарелка снизу стопки используется последней. 
А очередь можно сравнить с выстроившейся очередью к окошку в банке: клиент, стоящий в очереди первым, обслуживается первым.


Ниже приведена общая форма разновидности for-each цикла for. 
fоr(тип итр_пер : коллекция) 
блок_операторов

Инкапсуляция не позволяет видоизменить объект 
Приват поле ссылка на массив и размер массива 
они приват -> нельзя позже обратиться к конкретному эл-ту массива за границей массива и словить ошибку
обращение только через методы которые если что обработают выход за границу


Перегрузка методов является одним из способов реализации принципа полиморфизма в Java.

Перегрузка методов поддерживает полиморфизм, поскольку она является одним из способов реализации парадигмы "один интерфейс - множество методов".

В методе типа static допускается непосредственный вызов только других методов типа static; 
для метода типа static непосредственно доступными оказываются только друтие данные типа static, определенные в его классе; 
в методе типа static должна отсутствовать ссылка this.

Статический вложенный класс объявляется с помощью модификатора static. 
Являясь статическим, он может непосредственно обращаться к любому статическому члену своего внешнего класса. 
Другие члены внешнего класса доступны ему посредством ссылки на объект. 


Смысл статического вложенного класса? 
мой пример : во внешнем классе написать кучу отдельных методов, в статическом их обобщить в 1 глобальный
Вызов вида: VneshniyClass.InnerClass.methodName(VneshniyClass ob)|

Итак, имея в своем распоряжении суперкласс, определяющий общие свойства некоторых объектов, 
можно создать на его основе специализированные подклассы. 
Каждый подкласс дополняет свойства суперкласса собственными уникальными свойствами.
В этом и состоит сущность наследования. 

Вообще говоря, ссылочная переменная может указывать только на объекты своего типа.

Про полиморфизм 
есть надкласс с методом и от него есть два разных подкласса с переопределенным методом
создаю ссылку на надкласс  и присваиваю ей поочередно ссылку проинициализрованного надкласса и двух подклассов; 
-> вызываются соотв  переопр. методы

Подклассы получают достаточную свободу в определении собственных методов, реализуя в то же время согласованный интерфейс. 
Сочетая наследование с переопределением методов, в суперклассе можно определить общую форму методов для использования во всех ero подклассах.
Ссылочная переменная суперкласса может ссылаться на объект его подкласса.
Ключевое слово final позволяет без труда запретить переопределение метода или наследование класса.

С точки зрения синтаксиса интерфейсы подобны абстрактным классам. 
Но в интерфейсе ни у одного из методов не должно быть тела.
Это означает, что в интерфейсе вообще не предоставляется никакой реализации. 
В нем указывается только, что именно следует делать, но не как это делать. 
Как только интерфейс будет определен, он может быть реализован в любом количестве классов.
Кроме того, в одном классе может быть реализовано любое количество интерфейсов.

Интерфейсные ссылки - можно создать interfaceName varName; 
ее можно приравнивать к экземплярам классов реализующих интерфейс этот
и через нее можно вызывать переопределенные методы, к ост данным доступа не будет

В интерфейсе можно сделать реализацию метода (по умолчанию) дописав default и реализацию
чтобы не делать переопределение в классе использующим интерфейс и не нарушать работу программы

Следует также отметить, что статические методы интерфейса не наследуются ни реализующим его классом, ни производными интерфейсами.
___________________________________________________________

05.12.2020 Главы 9-10 : Страница 326-397;

## Обработка исключений
catch мы обрабатываем от подкласса к суперклассу 
Вложенные блоки try - catch если во вложенном не обрабатывается ошибка она передается в обрамляющий 
throw new ArithmeticException(); - генерация исключения вручную

Так, например, повторное генерирование исключения имеет смысл в том случае,
если один обработчик оперирует одним свойством исключения, а другой ориентирован на другое его свойство. 
Повторно сгенерированное исключение не может быть перехвачено тем же самым блоком catch.
Оно распространяется в следующий блок catch. 

С помощью метода printStackTrace () можно вывести стандартное сообщение об ошибке и запись последовательности вызовов методов,
которые привели к возникновению исключения.
А метод toString () позволяет получить стандартное сообщение об ошибке.
Этот метод также вызывается в том случае, когда объект исключения передается в качестве параметра методу println (). 

Блок finally выполняется всегда по завершении блока try/catch, независимо от того, какое именно условие к этому привело. 
Следовательно, блок finally получит управление как при нормальной работе программы, так и при возникновении ошибки. 
Более того, он будет вызван даже в том случае, если в блоке try или в одном из блоков catch будет присутствовать оператор return 
для немедленного возврата из метода.

Возле метода или класса пишем throws ExceptionName - зачем ? 
Чтобы не обрабатывать там эту ошибку а полномочия по обработке передавать вызывающему методу(Зачастую main);
Еще можно в catch передавать несколько исключений с помощью исключающего или | чтобы не дублировать код(неявно передаются как final);

Цепочечные исключения. Например ошибка деления на нуль, возникшая по причине ошибки ввода вывода и неправильного установления знаменателя.
Throwable getCause();

## Ввод-вывод данных

В классе PrintStream реализованы два дополнительных метода, printf () и format (), 
которые позволяют управлять форматированием выводимых данных. Например, они позволяют указать для выводимых данных количество 
десятичных цифр, минимальную ширину поля или способ представления отрицательных числовых значений. 
И хотя эти методы не используются в примерах, представленных в данной книге, вам стоит обратить на них пристальное внимание, 
поскольку они могут пригодиться вам при написании прикладных программ. 

Обратите внимание на то, как открывается файл в операторе try с ресурсами: 
try(FileinputStrearn fin = new FileinputStrearn(args[O])) 
по завершению блока try файл неявно закроется сам

Стоит упомянуть еще об одной особенности оператора try с ресурсами. 
Вообще говоря, возникшее при выполнении блока try исключение может породить другое исключение при закрытии ресурса в блоке finally. 
В случае "обычного" оператора try первоначальное исключение теряется, будучи прерванным вторым исключением. 
Но в случае оператора try с ресурсами второе исключение подавляется. При этом оно не теряется, а просто добавляется в 
список подавленных исключений, связанных с первым исключением. Этот список можно получить вызвав метод getSuppressed() класса Throwable
File - символьный, Data - байтовый
Глава 10(ввод - вывод данных) - бред сумасшедшего. Консоли мне хватит. (Надеюсь?)
___________________________________________________________

06.12.2020	
